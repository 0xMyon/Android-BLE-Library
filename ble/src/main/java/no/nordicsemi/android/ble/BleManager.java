/*
 * Copyright (c) 2015, Nordic Semiconductor
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package no.nordicsemi.android.ble;

import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothGatt;
import android.bluetooth.BluetoothGattCallback;
import android.bluetooth.BluetoothGattCharacteristic;
import android.bluetooth.BluetoothGattDescriptor;
import android.bluetooth.BluetoothGattService;
import android.bluetooth.BluetoothProfile;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Build;
import android.os.Handler;
import android.os.Looper;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.RequiresApi;
import android.support.annotation.StringRes;
import android.util.Log;

import java.lang.reflect.Method;
import java.util.Deque;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.UUID;

import no.nordicsemi.android.ble.callback.ConnectionPriorityCallback;
import no.nordicsemi.android.ble.callback.DataReceivedCallback;
import no.nordicsemi.android.ble.callback.FailCallback;
import no.nordicsemi.android.ble.callback.MtuCallback;
import no.nordicsemi.android.ble.callback.SuccessCallback;
import no.nordicsemi.android.ble.data.Data;
import no.nordicsemi.android.ble.data.DataSplitter;
import no.nordicsemi.android.ble.error.GattError;
import no.nordicsemi.android.ble.utils.ILogger;
import no.nordicsemi.android.ble.utils.ParserUtils;
import no.nordicsemi.android.log.ILogSession;
import no.nordicsemi.android.log.LogContract.Log.Level;
import no.nordicsemi.android.log.Logger;

// DO NOT EDIT THIS FILE UNLESS NECESSARY!
/**
 * <p>
 * The BleManager is responsible for managing the low level communication with a Bluetooth LE device.
 * Please see profiles implementation in Android nRF Blinky or Android nRF Toolbox app for an
 * example of use.
 * <p>
 * This base manager has been tested against number of devices and samples from Nordic SDK.
 * <p>
 * The manager handles connection events and initializes the device after establishing the connection.
 * <ol>
 * 	<li>For bonded devices it ensures that the Service Changed indications, if this characteristic
 * 	is present, are enabled. Android does not enable them by default, leaving this to the
 * 	developers.</li>
 * 	<li>The manager tries to read the Battery Level characteristic. No matter the result of this
 * 	operation (for example the Battery Level characteristic may not have the READ property)
 * 	it tries to enable Battery Level notifications, to get battery updates from the device.</li>
 * 	<li>Afterwards, the manager initializes the device using given queue of commands.
 * 	See {@link BleManagerGattCallback#initGatt(BluetoothGatt)} method for more details.</li>
 * 	<li>When initialization complete, the {@link BleManagerCallbacks#onDeviceReady(BluetoothDevice)}
 * 	callback is called.</li>
 * </ol>
 * The manager also is responsible for parsing the Battery Level values and calling
 * {@link BleManagerCallbacks#onBatteryValueReceived(BluetoothDevice, int)} method.
 * <p>
 * If {@link #setLogger(ILogSession)} was called, the events are logged into the nRF Logger
 * application, which may be downloaded from Google Play:
 * <a href="https://play.google.com/store/apps/details?id=no.nordicsemi.android.log">https://play.google.com/store/apps/details?id=no.nordicsemi.android.log</a>
 * <p>
 * The nRF Logger application allows you to see application logs without need to connect it to the computer.
 * <p>
 * The BleManager should be overridden in your app and all the 'high level' callbacks should be called from there.
 * Keeping this file as is (and {@link BleManagerCallbacks} as well) will allow to quickly update it when an update is posted here.
 *
 * @param <E> The profile callbacks type
 */
@SuppressWarnings({"WeakerAccess", "unused", "UnusedReturnValue", "DeprecatedIsStillUsed", "deprecation"})
public abstract class BleManager<E extends BleManagerCallbacks> implements ILogger {
	private final static String TAG = "BleManager";

	private final static UUID CLIENT_CHARACTERISTIC_CONFIG_DESCRIPTOR_UUID = UUID.fromString("00002902-0000-1000-8000-00805f9b34fb");

	private final static UUID BATTERY_SERVICE = UUID.fromString("0000180F-0000-1000-8000-00805f9b34fb");
	private final static UUID BATTERY_LEVEL_CHARACTERISTIC = UUID.fromString("00002A19-0000-1000-8000-00805f9b34fb");

	private final static UUID GENERIC_ATTRIBUTE_SERVICE = UUID.fromString("00001801-0000-1000-8000-00805f9b34fb");
	private final static UUID SERVICE_CHANGED_CHARACTERISTIC = UUID.fromString("00002A05-0000-1000-8000-00805f9b34fb");

	private final Object mLock = new Object();
	private final Context mContext;
	private final Handler mHandler;
	/**
	 * The log session or null if nRF Logger is not installed.
	 */
	private ILogSession mLogSession;
	private BluetoothGatt mBluetoothGatt;
	private BluetoothDevice mBluetoothDevice;
	private BleManagerGattCallback mGattCallback;
	protected E mCallbacks;
	/**
	 * This flag is set to false only when the {@link #shouldAutoConnect()} method returns true and
	 * the device got disconnected without calling {@link #disconnect()} method.
	 * If {@link #shouldAutoConnect()} returns false (default) this is always set to true.
	 */
	private boolean mUserDisconnected;
	/**
	 * Flag set to true when {@link #shouldAutoConnect()} method returned <code>true</code>.
	 * The first connection attempt is done with <code>autoConnect</code> flag set to false
	 * (to make the first connection quick) but on connection lost the manager will call
	 * {@link #connect(BluetoothDevice)} again. This time this method will call
	 * {@link BluetoothGatt#connect()} which always uses <code>autoConnect</code> equal true.
	 */
	private boolean mInitialConnection;
	/**
	 * Flag set to true when the device is connected.
	 */
	private boolean mConnected;
	/**
	 * Connection state. One of {@link BluetoothGatt#STATE_CONNECTED},
	 * {@link BluetoothGatt#STATE_CONNECTING}, {@link BluetoothGatt#STATE_DISCONNECTED},
	 * {@link BluetoothGatt#STATE_DISCONNECTING}.
	 */
	private int mConnectionState = BluetoothGatt.STATE_DISCONNECTED;
	/**
	 * Last received battery value or -1 if value wasn't received.
	 *
	 * @deprecated Battery value should be kept in the profile manager instead.
	 */
	@Deprecated
	private int mBatteryValue = -1;
	/**
	 * The current MTU (Maximum Transfer Unit). The maximum number of bytes that can be sent in
	 * a single packet is MTU-3.
	 */
	private int mMtu = 23;
	/**
	 * Currently performed request or null in idle state.
	 */
	private Request mRequest;
	/**
	 * A map of {@link ValueChangedCallback} for notifications and indications which contain value
	 * callback and data merger.
	 * If notifications/indications for given characteristic are enabled, the request are added
	 * to the map. Whenever a characteristic value changes, a proper callback is notified.
	 */
	private final HashMap<BluetoothGattCharacteristic, ValueChangedCallback> mNotificationCallbacks = new HashMap<>();
	@Deprecated
	private ValueChangedCallback mBatteryLevelNotificationCallback;

	private final BroadcastReceiver mBluetoothStateBroadcastReceiver = new BroadcastReceiver() {
		@Override
		public void onReceive(final Context context, final Intent intent) {
			final int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.STATE_OFF);
			final int previousState = intent.getIntExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, BluetoothAdapter.STATE_OFF);

			final String stateString = "[Broadcast] Action received: " + BluetoothAdapter.ACTION_STATE_CHANGED +
					", state changed to " + state2String(state);
			log(Level.DEBUG, stateString);

			switch (state) {
				case BluetoothAdapter.STATE_TURNING_OFF:
				case BluetoothAdapter.STATE_OFF:
					if (mConnected && previousState != BluetoothAdapter.STATE_TURNING_OFF && previousState != BluetoothAdapter.STATE_OFF) {
						// The connection is killed by the system, no need to gently disconnect
						mGattCallback.notifyDeviceDisconnected(mBluetoothDevice);
					}
					// Calling close() will prevent the STATE_OFF event from being logged (this receiver will be unregistered). But it doesn't matter.
					close();
					break;
			}
		}

		private String state2String(final int state) {
			switch (state) {
				case BluetoothAdapter.STATE_TURNING_ON:
					return "TURNING ON";
				case BluetoothAdapter.STATE_ON:
					return "ON";
				case BluetoothAdapter.STATE_TURNING_OFF:
					return "TURNING OFF";
				case BluetoothAdapter.STATE_OFF:
					return "OFF";
				default:
					return "UNKNOWN (" + state + ")";
			}
		}
	};

	private BroadcastReceiver mBondingBroadcastReceiver = new BroadcastReceiver() {
		@Override
		public void onReceive(final Context context, final Intent intent) {
			final BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
			final int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, -1);
			final int previousBondState = intent.getIntExtra(BluetoothDevice.EXTRA_PREVIOUS_BOND_STATE, -1);

			// Skip other devices
			if (mBluetoothDevice == null || !device.getAddress().equals(mBluetoothDevice.getAddress()))
				return;

			log(Level.DEBUG, "[Broadcast] Action received: " + BluetoothDevice.ACTION_BOND_STATE_CHANGED +
					", bond state changed to: " + bondStateToString(bondState) + " (" + bondState + ")");

			switch (bondState) {
				case BluetoothDevice.BOND_NONE:
					if (previousBondState == BluetoothDevice.BOND_BONDING) {
						mCallbacks.onBondingFailed(device);
						if (mRequest != null)
							mRequest.notifyFail(device, FailCallback.REASON_REQUEST_FAILED);
					}
					break;
				case BluetoothDevice.BOND_BONDING:
					mCallbacks.onBondingRequired(device);
					return;
				case BluetoothDevice.BOND_BONDED:
					log(Level.INFO, "Device bonded");
					mCallbacks.onBonded(device);
					if (mRequest != null && mRequest.type == Request.Type.CREATE_BOND)
						mRequest.notifySuccess(device);
					// If the device started to pair just after the connection was established the services were not discovered.
					if (mBluetoothGatt.getServices().isEmpty()) {
						mHandler.post(() -> {
							log(Level.VERBOSE, "Discovering Services...");
							log(Level.DEBUG, "gatt.discoverServices()");
							mBluetoothGatt.discoverServices();
						});
						return;
					}
					break;
			}
			if (mGattCallback != null)
				mGattCallback.nextRequest();
		}
	};

	private final BroadcastReceiver mPairingRequestBroadcastReceiver = new BroadcastReceiver() {
		@Override
		public void onReceive(final Context context, final Intent intent) {
			final BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);

			// Skip other devices
			if (mBluetoothDevice == null || !device.getAddress().equals(mBluetoothDevice.getAddress()))
				return;

			// String values are used as the constants are not available for Android 4.3.
			final int variant = intent.getIntExtra("android.bluetooth.device.extra.PAIRING_VARIANT"/*BluetoothDevice.EXTRA_PAIRING_VARIANT*/, 0);
			log(Level.DEBUG, "[Broadcast] Action received: android.bluetooth.device.action.PAIRING_REQUEST"/*BluetoothDevice.ACTION_PAIRING_REQUEST*/ +
					", pairing variant: " + pairingVariantToString(variant) + " (" + variant + ")");

			onPairingRequestReceived(device, variant);
		}
	};

	/**
	 * This method will be called if a remote device requires a non-'just works' pairing.
	 * See PAIRING_* constants for possible options.
	 *
	 * @param device  the device
	 * @param variant pairing variant
	 */
	protected void onPairingRequestReceived(final BluetoothDevice device, final int variant) {
		// The API below is available for Android 4.4 or newer.

		// An app may set the PIN here or set pairing confirmation (depending on the variant) using:
		// device.setPin(new byte[] { '1', '2', '3', '4', '5', '6' });
		// device.setPairingConfirmation(true);

		// However, setting the PIN here will not prevent from displaying the default pairing
		// dialog, which is shown by another application (Bluetooth Settings).
	}

	/**
	 * The manager constructor.
	 * <p>
	 * After constructing the manager, the callbacks object must be set with
	 * {@link #setGattCallbacks(BleManagerCallbacks)}.
	 * <p>
	 * To connect a device, call {@link #connect(BluetoothDevice)}.
	 *
	 * @param context context
	 */
	public BleManager(@NonNull final Context context) {
		mContext = context;
		mHandler = new Handler(Looper.getMainLooper());
	}

	/**
	 * Returns the context that the manager was created with.
	 *
	 * @return the context
	 */
	@NonNull
	protected Context getContext() {
		return mContext;
	}

	/**
	 * This method must return the gatt callback used by the manager.
	 * This method must not create a new gatt callback each time it is being invoked, but rather
	 * return a single object.
	 *
	 * @return the gatt callback object
	 */
	@NonNull
	protected abstract BleManagerGattCallback getGattCallback();

	/**
	 * Returns whether to connect to the remote device just once (false) or to add the address to
	 * white list of devices that will be automatically connect as soon as they become available (true).
	 * In the latter case, if Bluetooth adapter is enabled, Android scans periodically for devices
	 * from the white list and if a advertising packet is received from such, it tries to connect to it.
	 * When the connection is lost, the system will keep trying to reconnect to it in. If true is
	 * returned, and the connection to the device is lost the
	 * {@link BleManagerCallbacks#onLinkLossOccurred(BluetoothDevice)} callback is called instead of
	 * {@link BleManagerCallbacks#onDeviceDisconnected(BluetoothDevice)}.
	 * <p>This feature works much better on newer Android phone models and many not work on older phones.</p>
	 * <p>This method should only be used with bonded devices, as otherwise the device may change it's address.
	 * It will however work also with non-bonded devices with private static address. A connection attempt to
	 * a device with private resolvable address will fail.</p>
	 * <p>The first connection to a device will always be created with autoConnect flag to false
	 * (see {@link BluetoothDevice#connectGatt(Context, boolean, BluetoothGattCallback)}). This is
	 * to make it quick as the user most probably waits for a quick response. However, if this method
	 * returned true during first connection and the link was lost, the manager will try to reconnect
	 * to it using {@link BluetoothGatt#connect()} which forces autoConnect to true .</p>
	 *
	 * @return autoConnect flag value
	 */
	protected boolean shouldAutoConnect() {
		return false;
	}

	@SuppressLint("NewApi")
	public void connect(@NonNull final BluetoothDevice device) {
		connect(device, 1 /* BluetoothDevice.PHY_LE_1M */);
	}

	/**
	 * Connects to the Bluetooth Smart device.
	 *
	 * @param device a device to connect to
	 */
	@RequiresApi(api = Build.VERSION_CODES.O)
	public void connect(@NonNull final BluetoothDevice device, final int preferredPhy) {
		if (mCallbacks == null) {
			throw new NullPointerException("You have to set callbacks using setGattCallbacks(E callbacks) before connecting");
		}
		if (mConnected) {
			return;
		}

		runOnUiThread(() -> {
			synchronized (mLock) {
				if (mBluetoothGatt != null) {
					// There are 2 ways of reconnecting to the same device:
					// 1. Reusing the same BluetoothGatt object and calling connect() - this will force
					//    the autoConnect flag to true
					// 2. Closing it and reopening a new instance of BluetoothGatt object.
					// The gatt.close() is an asynchronous method. It requires some time before it's
					// finished and device.connectGatt(...) can't be called immediately or service
					// discovery may never finish on some older devices (Nexus 4, Android 5.0.1).
					// If shouldAutoConnect() method returned false we can't call gatt.connect() and
					// have to close gatt and open it again.
					if (!mInitialConnection) {
						log(Level.DEBUG, "gatt.close()");
						mBluetoothGatt.close();
						mBluetoothGatt = null;
						try {
							log(Level.DEBUG, "wait(200)");
							Thread.sleep(200); // Is 200 ms enough?
						} catch (final InterruptedException e) {
							// Ignore
						}
					} else {
						// Instead, the gatt.connect() method will be used to reconnect to the same device.
						// This method forces autoConnect = true even if the gatt was created with this
						// flag set to false.
						mInitialConnection = false;
						log(Level.VERBOSE, "Connecting...");
						mConnectionState = BluetoothGatt.STATE_CONNECTING;
						mCallbacks.onDeviceConnecting(device);
						log(Level.DEBUG, "gatt.connect()");
						mBluetoothGatt.connect();
						return;
					}
				} else {
					// Register bonding broadcast receiver
					mContext.registerReceiver(mBluetoothStateBroadcastReceiver, new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED));
					mContext.registerReceiver(mBondingBroadcastReceiver, new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED));
					mContext.registerReceiver(mPairingRequestBroadcastReceiver, new IntentFilter("android.bluetooth.device.action.PAIRING_REQUEST"/*BluetoothDevice.ACTION_PAIRING_REQUEST*/));
				}
			}

			final boolean shouldAutoConnect = shouldAutoConnect();
			// We will receive Link Loss events only when the device is connected with autoConnect=true
			mUserDisconnected = !shouldAutoConnect;
			// The first connection will always be done with autoConnect = false to make the connection quick.
			// If the shouldAutoConnect() method returned true, the manager will automatically try to
			// reconnect to this device on link loss.
			if (shouldAutoConnect)
				mInitialConnection = true;
			mBluetoothDevice = device;
			log(Level.VERBOSE, "Connecting...");
			mConnectionState = BluetoothGatt.STATE_CONNECTING;
			mCallbacks.onDeviceConnecting(device);
			log(Level.DEBUG, "gatt = device.connectGatt(autoConnect = false)");
			if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
				mBluetoothGatt = device.connectGatt(mContext, false, mGattCallback = getGattCallback(), BluetoothDevice.TRANSPORT_LE, preferredPhy, mHandler);
			} else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
				mBluetoothGatt = device.connectGatt(mContext, false, mGattCallback = getGattCallback(), BluetoothDevice.TRANSPORT_LE);
			} else {
				mBluetoothGatt = device.connectGatt(mContext, false, mGattCallback = getGattCallback());
			}
		});
	}

	/**
	 * Disconnects from the device or cancels the pending connection attempt. Does nothing if device was not connected.
	 *
	 * @return true if device is to be disconnected. False if it was already disconnected.
	 */
	public boolean disconnect() {
		mUserDisconnected = true;
		mInitialConnection = false;

		if (mBluetoothGatt != null) {
			mConnectionState = BluetoothGatt.STATE_DISCONNECTING;
			log(Level.VERBOSE, mConnected ? "Disconnecting..." : "Cancelling connection...");
			runOnUiThread(() -> mCallbacks.onDeviceDisconnecting(mBluetoothGatt.getDevice()));
			final boolean wasConnected = mConnected;
			log(Level.DEBUG, "gatt.disconnect()");
			runOnUiThread(() -> mBluetoothGatt.disconnect());

			if (!wasConnected) {
				// There will be no callback, the connection attempt will be stopped
				mConnectionState = BluetoothGatt.STATE_DISCONNECTED;
				log(Level.INFO, "Disconnected");
				runOnUiThread(() -> mCallbacks.onDeviceDisconnected(mBluetoothGatt.getDevice()));
			}
			return true;
		}
		return false;
	}

	/**
	 * Returns the Bluetooth device object used in {@link #connect(BluetoothDevice)}.
	 *
	 * @return the Bluetooth device or null, if {@link #connect(BluetoothDevice)} wasn't called.
	 */
	public BluetoothDevice getBluetoothDevice() {
		return mBluetoothDevice;
	}

	/**
	 * This method returns true if the device is connected. Services could have not been discovered yet.
	 */
	public boolean isConnected() {
		return mConnected;
	}

	/**
	 * Method returns the connection state:
	 * {@link BluetoothGatt#STATE_CONNECTING STATE_CONNECTING},
	 * {@link BluetoothGatt#STATE_CONNECTED STATE_CONNECTED},
	 * {@link BluetoothGatt#STATE_DISCONNECTING STATE_DISCONNECTING},
	 * {@link BluetoothGatt#STATE_DISCONNECTED STATE_DISCONNECTED}
	 *
	 * @return the connection state
	 */
	public int getConnectionState() {
		return mConnectionState;
	}

	/**
	 * Returns the last received value of Battery Level characteristic, or -1 if such does not exist,
	 * hasn't been read or notification wasn't received yet.
	 * <p>
	 * The value returned will be invalid if overridden {@link #readBatteryLevel()} and
	 * {@link #enableBatteryLevelNotifications()} were used.
	 * </p>
	 *
	 * @return the last battery level value in percent
	 * @deprecated Keep the battery level in your manager instead.
	 */
	@Deprecated
	public int getBatteryValue() {
		return mBatteryValue;
	}

	/**
	 * Closes and releases resources. May be also used to unregister broadcast listeners.
	 */
	public void close() {
		try {
			mContext.unregisterReceiver(mBluetoothStateBroadcastReceiver);
			mContext.unregisterReceiver(mBondingBroadcastReceiver);
			mContext.unregisterReceiver(mPairingRequestBroadcastReceiver);
		} catch (final Exception e) {
			// the receiver must have been not registered or unregistered before
		}
		synchronized (mLock) {
			if (mBluetoothGatt != null) {
				log(Level.DEBUG, "gatt.close()");
				mBluetoothGatt.close();
				mBluetoothGatt = null;
			}
			mConnected = false;
			mInitialConnection = false;
			mRequest = null;
			mNotificationCallbacks.clear();
			mConnectionState = BluetoothGatt.STATE_DISCONNECTED;
			if (mGattCallback != null)
				mGattCallback.cancelQueue();
			mGattCallback = null;
			mBluetoothDevice = null;
		}
	}

	/**
	 * Sets the optional log session. This session will be used to log Bluetooth events.
	 * The logs may be viewed using the nRF Logger application:
	 * https://play.google.com/store/apps/details?id=no.nordicsemi.android.log
	 * Since nRF Logger Library v2.0 an app may define it's own log provider.
	 * NOTE: nRF Logger must be installed prior to nRF Toolbox as it defines the required permission
	 * which is used by nRF Toolbox.
	 *
	 * @param session the session, or null if nRF Logger is not installed.
	 */
	public void setLogger(@Nullable final ILogSession session) {
		mLogSession = session;
	}

	@Override
	public void log(final int level, @NonNull final String message) {
		Logger.log(mLogSession, level, message);
	}

	@Override
	public void log(final int level, @StringRes final int messageRes, @Nullable final Object... params) {
		Logger.log(mLogSession, level, messageRes, params);
	}

	/**
	 * Sets the manager callback listener
	 *
	 * @param callbacks the callback listener
	 */
	public void setGattCallbacks(@NonNull E callbacks) {
		mCallbacks = callbacks;
	}

	/**
	 * Enqueues creating bond request to the queue.
	 *
	 * @return the request
	 */
	protected final Request createBond() {
		return enqueue(Request.createBond());
	}

	/**
	 * Creates a bond with the device. The device must be first set using {@link #connect(BluetoothDevice)} which will
	 * try to connect to the device. If you need to pair with a device before connecting to it you may do it without
	 * the use of BleManager object and connect after bond is established.
	 *
	 * @return true if pairing has started, false if it was already paired or an immediate error occur.
	 */
	private boolean internalCreateBond() {
		final BluetoothDevice device = mBluetoothDevice;
		if (device == null)
			return false;

		if (device.getBondState() == BluetoothDevice.BOND_BONDED) {
			log(Level.VERBOSE, "Creating bond request on already bonded device...");
			log(Level.INFO, "Device bonded");
			mRequest.notifySuccess(device);
			return false;
		}

		log(Level.VERBOSE, "Starting pairing...");

		boolean result = false;
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
			log(Level.DEBUG, "device.createBond()");
			result = device.createBond();
		} else {
			/*
			 * There is a createBond() method in BluetoothDevice class but for now it's hidden.
			 * We will call it using reflections. It has been revealed in KitKat (Api19)
			 */
			try {
				final Method createBond = device.getClass().getMethod("createBond");
				if (createBond != null) {
					log(Level.DEBUG, "device.createBond() (hidden)");
					result = (Boolean) createBond.invoke(device);
				}
			} catch (final Exception e) {
				Log.w(TAG, "An exception occurred while creating bond", e);
			}
		}

		if (!result) {
			Log.w(TAG, "Creating bond failed");
			mRequest.notifyFail(device, FailCallback.REASON_REQUEST_FAILED);
		}
		return result;
	}

	/**
	 * When the device is bonded and has the Generic Attribute service and the Service Changed
	 * characteristic this method enables indications on this characteristic.
	 * In case one of the requirements is not fulfilled this method returns <code>false</code>.
	 *
	 * @return <code>true</code> when the request has been sent, <code>false</code> when the device
	 * is not bonded, does not have the Generic Attribute service, the GA service does not have
	 * the Service Changed characteristic or this characteristic does not have the CCCD.
	 */
	private boolean ensureServiceChangedEnabled() {
		final BluetoothGatt gatt = mBluetoothGatt;
		if (gatt == null)
			return false;

		// The Service Changed indications have sense only on bonded devices
		final BluetoothDevice device = gatt.getDevice();
		if (device.getBondState() != BluetoothDevice.BOND_BONDED)
			return false;

		final BluetoothGattService gaService = gatt.getService(GENERIC_ATTRIBUTE_SERVICE);
		if (gaService == null)
			return false;

		final BluetoothGattCharacteristic scCharacteristic = gaService.getCharacteristic(SERVICE_CHANGED_CHARACTERISTIC);
		if (scCharacteristic == null)
			return false;

		log(Level.INFO, "Service Changed characteristic found on a bonded device");
		return internalEnableIndications(scCharacteristic);
	}

	/**
	 * Returns the callback that is registered for value changes (notifications) of given characteristic.
	 * After assigning the notifications callback, notifications must be enabled using
	 * {@link #enableNotifications(BluetoothGattCharacteristic)}. This applies also when they were
	 * already enabled on the remote side.
	 * <p>
	 * To remove the callback, disable notifications using {@link #disableNotifications(BluetoothGattCharacteristic)}.
	 * </p>
	 *
	 * @param characteristic characteristic to bind the callback with. If null, the returned callback
	 *                       will not be null, but will not be used.
	 * @return the callback
	 */
	@NonNull
	protected final ValueChangedCallback setNotificationCallback(final @Nullable BluetoothGattCharacteristic characteristic) {
		ValueChangedCallback callback = mNotificationCallbacks.get(characteristic);
		if (callback == null) {
			callback = new ValueChangedCallback(this);
			if (characteristic != null) {
				mNotificationCallbacks.put(characteristic, callback);
			}
		}
		return callback.free();
	}

	/**
	 * Returns the callback that is registered for value changes (indications) of given characteristic.
	 * After assigning the notifications callback, notifications must be enabled using
	 * {@link #enableIndications(BluetoothGattCharacteristic)}. This applies also when they were
	 * already enabled on the remote side.
	 * <p>
	 * To remove the callback, disable indications using {@link #disableIndications(BluetoothGattCharacteristic)}.
	 * </p>
	 *
	 * @param characteristic characteristic to bind the callback with. If null, the returned callback
	 *                       will not be null, but will not be used.
	 * @return the callback
	 */
	@NonNull
	protected final ValueChangedCallback setIndicationCallback(final @Nullable BluetoothGattCharacteristic characteristic) {
		return setNotificationCallback(characteristic);
	}

	/**
	 * Enables notifications on given characteristic.
	 * If the characteristic is null the {@link Request#fail(FailCallback) fail(FailCallback)}
	 * callback will be called.
	 *
	 * @return the request
	 */
	@NonNull
	protected final WriteRequest enableNotifications(final @Nullable BluetoothGattCharacteristic characteristic) {
		return enqueue(Request.newEnableNotificationsRequest(characteristic));
	}

	private boolean internalEnableNotifications(final BluetoothGattCharacteristic characteristic) {
		final BluetoothGatt gatt = mBluetoothGatt;
		if (gatt == null || characteristic == null)
			return false;

		// Check characteristic property
		final int properties = characteristic.getProperties();
		if ((properties & BluetoothGattCharacteristic.PROPERTY_NOTIFY) == 0)
			return false;

		log(Level.DEBUG, "gatt.setCharacteristicNotification(" + characteristic.getUuid() + ", true)");
		gatt.setCharacteristicNotification(characteristic, true);
		final BluetoothGattDescriptor descriptor = characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG_DESCRIPTOR_UUID);
		if (descriptor != null) {
			descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);
			log(Level.VERBOSE, "Enabling notifications for " + characteristic.getUuid());
			log(Level.DEBUG, "gatt.writeDescriptor(" + CLIENT_CHARACTERISTIC_CONFIG_DESCRIPTOR_UUID + ", value=0x01-00)");
			return internalWriteDescriptorWorkaround(descriptor);
		}
		return false;
	}

	/**
	 * Enables notifications on given characteristic.
	 * If the characteristic is null the {@link Request#fail(FailCallback) fail(FailCallback)}
	 * callback will be called.
	 *
	 * @return the request
	 */
	@NonNull
	protected final WriteRequest disableNotifications(final @Nullable BluetoothGattCharacteristic characteristic) {
		return enqueue(Request.newDisableNotificationsRequest(characteristic));
	}

	private boolean internalDisableNotifications(final BluetoothGattCharacteristic characteristic) {
		final BluetoothGatt gatt = mBluetoothGatt;
		if (gatt == null || characteristic == null)
			return false;

		// Check characteristic property
		final int properties = characteristic.getProperties();
		if ((properties & BluetoothGattCharacteristic.PROPERTY_NOTIFY) == 0)
			return false;

		log(Level.DEBUG, "gatt.setCharacteristicNotification(" + characteristic.getUuid() + ", false)");
		gatt.setCharacteristicNotification(characteristic, false);
		final BluetoothGattDescriptor descriptor = characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG_DESCRIPTOR_UUID);
		if (descriptor != null) {
			descriptor.setValue(BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);
			log(Level.VERBOSE, "Disabling notifications and indications for " + characteristic.getUuid());
			log(Level.DEBUG, "gatt.writeDescriptor(" + CLIENT_CHARACTERISTIC_CONFIG_DESCRIPTOR_UUID + ", value=0x00-00)");
			return internalWriteDescriptorWorkaround(descriptor);
		}
		return false;
	}

	/**
	 * Enables indications on given characteristic.
	 * If the characteristic is null the {@link Request#fail(FailCallback) fail(FailCallback)}
	 * callback will be called.
	 *
	 * @return the request
	 */
	@NonNull
	protected final WriteRequest enableIndications(final @Nullable BluetoothGattCharacteristic characteristic) {
		return enqueue(Request.newEnableIndicationsRequest(characteristic));
	}

	private boolean internalEnableIndications(final BluetoothGattCharacteristic characteristic) {
		final BluetoothGatt gatt = mBluetoothGatt;
		if (gatt == null || characteristic == null)
			return false;

		// Check characteristic property
		final int properties = characteristic.getProperties();
		if ((properties & BluetoothGattCharacteristic.PROPERTY_INDICATE) == 0)
			return false;

		log(Level.DEBUG, "gatt.setCharacteristicNotification(" + characteristic.getUuid() + ", true)");
		gatt.setCharacteristicNotification(characteristic, true);
		final BluetoothGattDescriptor descriptor = characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG_DESCRIPTOR_UUID);
		if (descriptor != null) {
			descriptor.setValue(BluetoothGattDescriptor.ENABLE_INDICATION_VALUE);
			log(Level.VERBOSE, "Enabling indications for " + characteristic.getUuid());
			log(Level.DEBUG, "gatt.writeDescriptor(" + CLIENT_CHARACTERISTIC_CONFIG_DESCRIPTOR_UUID + ", value=0x02-00)");
			return internalWriteDescriptorWorkaround(descriptor);
		}
		return false;
	}

	/**
	 * Enables indications on given characteristic.
	 * If the characteristic is null the {@link Request#fail(FailCallback) fail(FailCallback)}
	 * callback will be called.
	 *
	 * @return the request
	 */
	@NonNull
	protected final WriteRequest disableIndications(final @Nullable BluetoothGattCharacteristic characteristic) {
		return enqueue(Request.newDisableIndicationsRequest(characteristic));
	}

	private boolean internalDisableIndications(final BluetoothGattCharacteristic characteristic) {
		// This writes exactly the same settings so do not duplicate code
		return internalDisableNotifications(characteristic);
	}

	/**
	 * Sends the read request to the given characteristic.
	 * If the characteristic is null the {@link Request#fail(FailCallback) fail(FailCallback)}
	 * callback will be called.
	 *
	 * @param characteristic the characteristic to read
	 * @return the request
	 */
	@NonNull
	protected final ReadRequest readCharacteristic(final @Nullable BluetoothGattCharacteristic characteristic) {
		return enqueue(Request.newReadRequest(characteristic));
	}

	private boolean internalReadCharacteristic(final BluetoothGattCharacteristic characteristic) {
		final BluetoothGatt gatt = mBluetoothGatt;
		if (gatt == null || characteristic == null)
			return false;

		// Check characteristic property
		final int properties = characteristic.getProperties();
		if ((properties & BluetoothGattCharacteristic.PROPERTY_READ) == 0)
			return false;

		log(Level.VERBOSE, "Reading characteristic " + characteristic.getUuid());
		log(Level.DEBUG, "gatt.readCharacteristic(" + characteristic.getUuid() + ")");
		return gatt.readCharacteristic(characteristic);
	}

	/**
	 * Writes the characteristic value to the given characteristic. The write type is taken from the
	 * characteristic.
	 * <p>
	 * Use {@link WriteRequest#split() split()} or {@link WriteRequest#split(DataSplitter) split(DataSplitter)}
	 * on the returned {@link WriteRequest} if data should be automatically split into multiple packets.
	 * If the characteristic is null the {@link Request#fail(FailCallback) fail(FailCallback)}
	 * callback will be called.
	 * </p>
	 *
	 * @param characteristic the characteristic to write to
	 * @return the request
	 */
	@NonNull
	protected final WriteRequest writeCharacteristic(final @Nullable BluetoothGattCharacteristic characteristic) {
		return enqueue(Request.newWriteRequest(characteristic, characteristic != null ? characteristic.getValue() : null));
	}

	/**
	 * Writes the given data to the characteristic. The write type is taken from the characteristic.
	 * <p>
	 * Use {@link WriteRequest#split() split()} or {@link WriteRequest#split(DataSplitter) split(ValueSplitter)}
	 * on the returned {@link WriteRequest} if data should be automatically split into multiple packets.
	 * If the characteristic is null the {@link Request#fail(FailCallback) fail(FailCallback)}
	 * callback will be called.
	 * </p>
	 *
	 * @param characteristic the characteristic to write to
	 * @param data           data to be written to the characteristic
	 * @return the request
	 */
	@NonNull
	protected final WriteRequest writeCharacteristic(final @Nullable BluetoothGattCharacteristic characteristic, final @Nullable Data data) {
		return enqueue(Request.newWriteRequest(characteristic, data != null ? data.getValue() : null));
	}

	/**
	 * Writes the given data to the characteristic. The write type is taken from the characteristic.
	 * <p>
	 * Use {@link WriteRequest#split() split()} or {@link WriteRequest#split(DataSplitter) split(ValueSplitter)}
	 * on the returned {@link WriteRequest} if data should be automatically split into multiple packets.
	 * If the characteristic is null the {@link Request#fail(FailCallback) fail(FailCallback)}
	 * callback will be called.
	 * </p>
	 *
	 * @param characteristic the characteristic to write to
	 * @param data           data to be written to the characteristic
	 * @return the request
	 */
	@NonNull
	protected final WriteRequest writeCharacteristic(final @Nullable BluetoothGattCharacteristic characteristic, final @Nullable byte[] data) {
		return enqueue(Request.newWriteRequest(characteristic, data));
	}

	/**
	 * Writes at most length bytes from offset at given data to the characteristic.
	 * The write type is taken from the characteristic.
	 * <p>
	 * Use {@link WriteRequest#split() split()} or {@link WriteRequest#split(DataSplitter) split(ValueSplitter)}
	 * on the returned {@link WriteRequest} if data should be automatically split into multiple packets.
	 * If the characteristic is null the {@link Request#fail(FailCallback) fail(FailCallback)}
	 * callback will be called.
	 * </p>
	 *
	 * @param characteristic the characteristic to write to
	 * @param data           data to be written to the characteristic
	 * @param offset         index of the first byte to be sent
	 * @param length         number of bytes to be sent
	 * @return the request
	 */
	@NonNull
	protected final WriteRequest writeCharacteristic(final @Nullable BluetoothGattCharacteristic characteristic, final @Nullable byte[] data, final int offset, final int length) {
		return enqueue(Request.newWriteRequest(characteristic, data, offset, length));
	}

	private boolean internalWriteCharacteristic(final BluetoothGattCharacteristic characteristic) {
		final BluetoothGatt gatt = mBluetoothGatt;
		if (gatt == null || characteristic == null)
			return false;

		// Check characteristic property
		final int properties = characteristic.getProperties();
		if ((properties & (BluetoothGattCharacteristic.PROPERTY_WRITE | BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE)) == 0)
			return false;

		log(Level.VERBOSE, "Writing characteristic " + characteristic.getUuid() + " (" + writeTypeToString(characteristic.getWriteType()) + ")");
		log(Level.DEBUG, "gatt.writeCharacteristic(" + characteristic.getUuid() + ")");
		return gatt.writeCharacteristic(characteristic);
	}

	/**
	 * Sends the read request to the given descriptor.
	 * If the descriptor is null the {@link Request#fail(FailCallback) fail(FailCallback)}
	 * callback will be called.
	 *
	 * @param descriptor the descriptor to read
	 * @return the request
	 */
	@NonNull
	protected final ReadRequest readDescriptor(final @Nullable BluetoothGattDescriptor descriptor) {
		return enqueue(Request.newReadRequest(descriptor));
	}

	private boolean internalReadDescriptor(final BluetoothGattDescriptor descriptor) {
		final BluetoothGatt gatt = mBluetoothGatt;
		if (gatt == null || descriptor == null)
			return false;

		log(Level.VERBOSE, "Reading descriptor " + descriptor.getUuid());
		log(Level.DEBUG, "gatt.readDescriptor(" + descriptor.getUuid() + ")");
		return gatt.readDescriptor(descriptor);
	}

	/**
	 * Writes the descriptor value to the given descriptor.
	 * <p>
	 * Use {@link WriteRequest#split() split()} or {@link WriteRequest#split(DataSplitter) split(ValueSplitter)}
	 * on the returned {@link WriteRequest} if data should be automatically split into multiple packets.
	 * If the descriptor is null the {@link Request#fail(FailCallback) fail(FailCallback)}
	 * callback will be called.
	 * </p>
	 *
	 * @param descriptor the descriptor to write to
	 * @return the request
	 */
	@NonNull
	protected final WriteRequest writeDescriptor(final @Nullable BluetoothGattDescriptor descriptor) {
		return enqueue(Request.newWriteRequest(descriptor, descriptor != null ? descriptor.getValue() : null));
	}

	/**
	 * Writes the given data to the descriptor.
	 * <p>
	 * Use {@link WriteRequest#split() split()} or {@link WriteRequest#split(DataSplitter) split(ValueSplitter)}
	 * on the returned {@link WriteRequest} if data should be automatically split into multiple packets.
	 * If the descriptor is null the {@link Request#fail(FailCallback) fail(FailCallback)}
	 * callback will be called.
	 * </p>
	 *
	 * @param descriptor the descriptor to write to
	 * @param data       data to be written to the descriptor
	 * @return the request
	 */
	@NonNull
	protected final WriteRequest writeDescriptor(final @Nullable BluetoothGattDescriptor descriptor, final @Nullable Data data) {
		return enqueue(Request.newWriteRequest(descriptor, data != null ? data.getValue() : null));
	}

	/**
	 * Writes the given data to the descriptor.
	 * <p>
	 * Use {@link WriteRequest#split() split()} or {@link WriteRequest#split(DataSplitter) split(ValueSplitter)}
	 * on the returned {@link WriteRequest} if data should be automatically split into multiple packets.
	 * If the descriptor is null the {@link Request#fail(FailCallback) fail(FailCallback)}
	 * callback will be called.
	 * </p>
	 *
	 * @param descriptor the descriptor to write to
	 * @param data       data to be written to the descriptor
	 * @return the request
	 */
	@NonNull
	protected final WriteRequest writeDescriptor(final @Nullable BluetoothGattDescriptor descriptor, final @Nullable byte[] data) {
		return enqueue(Request.newWriteRequest(descriptor, data));
	}

	/**
	 * Writes at most length bytes from offset at given data to the descriptor.
	 * <p>
	 * Use {@link WriteRequest#split() split()} or {@link WriteRequest#split(DataSplitter) split(ValueSplitter)}
	 * on the returned {@link WriteRequest} if data should be automatically split into multiple packets.
	 * If the descriptor is null the {@link Request#fail(FailCallback) fail(FailCallback)}
	 * callback will be called.
	 * </p>
	 *
	 * @param descriptor the descriptor to write to
	 * @param data       data to be written to the descriptor
	 * @param offset     index of the first byte to be sent
	 * @param length     number of bytes to be sent
	 * @return the request
	 */
	@NonNull
	protected final WriteRequest writeDescriptor(final @Nullable BluetoothGattDescriptor descriptor, final @Nullable byte[] data, final int offset, final int length) {
		return enqueue(Request.newWriteRequest(descriptor, data, offset, length));
	}

	private boolean internalWriteDescriptor(final BluetoothGattDescriptor descriptor) {
		final BluetoothGatt gatt = mBluetoothGatt;
		if (gatt == null || descriptor == null)
			return false;

		log(Level.VERBOSE, "Writing descriptor " + descriptor.getUuid());
		log(Level.DEBUG, "gatt.writeDescriptor(" + descriptor.getUuid() + ")");
		return internalWriteDescriptorWorkaround(descriptor);
	}

	/**
	 * Reads the battery level from the device.
	 * If the device does not have Battery Service the {@link Request#fail(FailCallback) fail(FailCallback)}
	 * callback will be called.
	 *
	 * @return the request
	 * @deprecated Use {@link #readCharacteristic(BluetoothGattCharacteristic)}.
	 * {@link ReadRequest#with(DataReceivedCallback) with(...)} instead.
	 */
	@SuppressWarnings("ConstantConditions")
	@NonNull
	@Deprecated
	protected ReadRequest readBatteryLevel() {
		return enqueue(Request.newReadBatteryLevelRequest()
				.with((device, data) -> {
					if (data.size() == 1) {
						final int batteryLevel = data.getIntValue(Data.FORMAT_UINT8, 0);
						log(Level.APPLICATION, "Battery Level received: " + batteryLevel + "%");
						mBatteryValue = batteryLevel;
						mGattCallback.onBatteryValueReceived(mBluetoothGatt, batteryLevel);
						mCallbacks.onBatteryValueReceived(device, batteryLevel);
					}
				}));
	}

	@Deprecated
	private boolean internalReadBatteryLevel() {
		final BluetoothGatt gatt = mBluetoothGatt;
		if (gatt == null)
			return false;

		final BluetoothGattService batteryService = gatt.getService(BATTERY_SERVICE);
		if (batteryService == null)
			return false;

		final BluetoothGattCharacteristic batteryLevelCharacteristic =
				batteryService.getCharacteristic(BATTERY_LEVEL_CHARACTERISTIC);
		return internalReadCharacteristic(batteryLevelCharacteristic);
	}

	/**
	 * This method enables notifications on the Battery Level characteristic.
	 * If the device does not have Battery Service the {@link Request#fail(FailCallback) fail(FailCallback)}
	 * callback will be called.
	 *
	 * @return the request
	 * @deprecated Use {@link #enableNotifications(BluetoothGattCharacteristic)}.
	 * {@link ReadRequest#with(DataReceivedCallback) with(batteryLevel -> ...)} instead.
	 */
	@SuppressWarnings("ConstantConditions")
	@NonNull
	@Deprecated
	protected WriteRequest enableBatteryLevelNotifications() {
		if (mBatteryLevelNotificationCallback == null) {
			mBatteryLevelNotificationCallback = new ValueChangedCallback(this)
					.with((device, data) -> {
						if (data.size() == 1) {
							final int batteryLevel = data.getIntValue(Data.FORMAT_UINT8, 0);
							mBatteryValue = batteryLevel;
							mGattCallback.onBatteryValueReceived(mBluetoothGatt, batteryLevel);
							mCallbacks.onBatteryValueReceived(device, batteryLevel);
						}
					});
		}
		return enqueue(Request.newEnableBatteryLevelNotificationsRequest())
				.done(device -> log(Level.INFO, "Battery Level notifications enabled"));
	}

	/**
	 * This method disables notifications on the Battery Level characteristic.
	 * If the device does not have Battery Service the {@link Request#fail(FailCallback) fail(FailCallback)}
	 * callback will be called.
	 *
	 * @return the request
	 * @deprecated Use {@link #disableNotifications(BluetoothGattCharacteristic)} instead.
	 */
	@NonNull
	@Deprecated
	protected WriteRequest disableBatteryLevelNotifications() {
		return enqueue(Request.newDisableBatteryLevelNotificationsRequest())
				.done(device -> log(Level.INFO, "Battery Level notifications disabled"));
	}

	@Deprecated
	private boolean internalSetBatteryNotifications(final boolean enable) {
		final BluetoothGatt gatt = mBluetoothGatt;
		if (gatt == null)
			return false;

		final BluetoothGattService batteryService = gatt.getService(BATTERY_SERVICE);
		if (batteryService == null)
			return false;

		final BluetoothGattCharacteristic batteryLevelCharacteristic = batteryService.getCharacteristic(BATTERY_LEVEL_CHARACTERISTIC);
		if (enable)
			return internalEnableNotifications(batteryLevelCharacteristic);
		else
			return internalDisableNotifications(batteryLevelCharacteristic);
	}

	/**
	 * There was a bug in Android up to 6.0 where the descriptor was written using parent
	 * characteristic's write type, instead of always Write With Response, as the spec says.
	 * <p>
	 * See: <a href="https://android.googlesource.com/platform/frameworks/base/+/942aebc95924ab1e7ea1e92aaf4e7fc45f695a6c%5E%21/#F0">
	 * https://android.googlesource.com/platform/frameworks/base/+/942aebc95924ab1e7ea1e92aaf4e7fc45f695a6c%5E%21/#F0</a>
	 * </p>
	 *
	 * @param descriptor the descriptor to be written
	 * @return the result of {@link BluetoothGatt#writeDescriptor(BluetoothGattDescriptor)}
	 */
	private boolean internalWriteDescriptorWorkaround(final BluetoothGattDescriptor descriptor) {
		final BluetoothGatt gatt = mBluetoothGatt;
		if (gatt == null || descriptor == null)
			return false;

		final BluetoothGattCharacteristic parentCharacteristic = descriptor.getCharacteristic();
		final int originalWriteType = parentCharacteristic.getWriteType();
		parentCharacteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT);
		final boolean result = gatt.writeDescriptor(descriptor);
		parentCharacteristic.setWriteType(originalWriteType);
		return result;
	}

	/**
	 * Requests new MTU. On Android Lollipop or newer it will send the MTU request to the connected
	 * device. On older versions of Android the {@link MtuCallback#onMtuChanged(BluetoothDevice, int)}
	 * set with {@link MtuRequest#with(MtuCallback)} will be called with current MTU value.
	 *
	 * @return the request
	 */
	protected final MtuRequest requestMtu(final int mtu) {
		return enqueue(Request.newMtuRequest(mtu));
	}

	/**
	 * Returns the current MTU (Maximum Transfer Unit). MTU specifies the maximum number of bytes that can
	 * be sent in a single write operation. 3 bytes are used for internal purposes, so the maximum size is MTU-3.
	 * The value will changed only if requested with {@link #requestMtu(int)} and a successful callback is received.
	 * If the peripheral requests MTU change, the {@link BluetoothGattCallback#onMtuChanged(BluetoothGatt, int, int)}
	 * callback is not invoked, therefor the returned MTU value will not be correct.
	 * Use {@link android.bluetooth.BluetoothGattServerCallback#onMtuChanged(BluetoothDevice, int)} to get the
	 * callback with right value requested from the peripheral side.
	 *
	 * @return the current MTU value. Default to 23.
	 */
	protected final int getMtu() {
		return mMtu;
	}

	/**
	 * This method overrides the MTU value. Use it only when the peripheral has changed MTU and you
	 * received the {@link android.bluetooth.BluetoothGattServerCallback#onMtuChanged(BluetoothDevice, int)}
	 * callback. If you want to set MTU as a master, use {@link #requestMtu(int)} instead.
	 *
	 * @param mtu the MTU value set by the peripheral.
	 */
	protected final void overrideMtu(final int mtu) {
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
			mMtu = mtu;
		}
	}

	@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
	private boolean internalRequestMtu(final int mtu) {
		final BluetoothGatt gatt = mBluetoothGatt;
		if (gatt == null)
			return false;

		log(Level.VERBOSE, "Requesting new MTU...");
		log(Level.DEBUG, "gatt.requestMtu(" + mtu + ")");
		return gatt.requestMtu(mtu);
	}

	/**
	 * Requests the new connection priority. Acceptable values are:
	 * <ol>
	 * <li>{@link BluetoothGatt#CONNECTION_PRIORITY_HIGH} - Interval: 11.25 -15 ms, latency: 0, supervision timeout: 20 sec,</li>
	 * <li>{@link BluetoothGatt#CONNECTION_PRIORITY_BALANCED} - Interval: 30 - 50 ms, latency: 0, supervision timeout: 20 sec,</li>
	 * <li>{@link BluetoothGatt#CONNECTION_PRIORITY_LOW_POWER} - Interval: 100 - 125 ms, latency: 2, supervision timeout: 20 sec.</li>
	 * </ol>
	 * Works only on Android Lollipop or newer. On older system versions will cause
	 * {@link Request#fail(FailCallback)} callback or throw
	 * {@link no.nordicsemi.android.ble.exception.RequestFailedException} with
	 * {@link FailCallback#REASON_REQUEST_FAILED} status if called synchronously.
	 * Starting from Android Oreo you may get a callback with the interval, latency and timeout
	 * using {@link ConnectionPriorityRequest#with(ConnectionPriorityCallback)}.
	 *
	 * @param priority one of: {@link BluetoothGatt#CONNECTION_PRIORITY_HIGH}, {@link BluetoothGatt#CONNECTION_PRIORITY_BALANCED},
	 *                 {@link BluetoothGatt#CONNECTION_PRIORITY_LOW_POWER}.
	 * @return the request
	 */
	@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
	protected final ConnectionPriorityRequest requestConnectionPriority(final int priority) {
		return enqueue(Request.newConnectionPriorityRequest(priority));
	}

	@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
	private boolean internalRequestConnectionPriority(final int priority) {
		final BluetoothGatt gatt = mBluetoothGatt;
		if (gatt == null)
			return false;

		String text, priorityText;
		switch (priority) {
			case BluetoothGatt.CONNECTION_PRIORITY_HIGH:
				text = Build.VERSION.SDK_INT >= Build.VERSION_CODES.M ? "HIGH (11.25–15ms, 0, 20s)" : "HIGH (7.5–10ms, 0, 20s)";
				priorityText = "HIGH";
				break;
			case BluetoothGatt.CONNECTION_PRIORITY_LOW_POWER:
				text = "BALANCED (30–50ms, 0, 20s)";
				priorityText = "LOW POWER";
				break;
			default:
			case BluetoothGatt.CONNECTION_PRIORITY_BALANCED:
				text = "LOW POWER (100–125ms, 2, 20s)";
				priorityText = "BALANCED";
				break;
		}
		log(Level.VERBOSE, "Requesting connection priority: " + text + "...");
		log(Level.DEBUG, "gatt.requestConnectionPriority(" + priorityText + ")");
		return gatt.requestConnectionPriority(priority);
	}

	/**
	 * Enqueues a new request. The request will be handled immediately if there is no operation in
	 * progress, or automatically after the last enqueued one will finish.
	 * <p>This method should be used to read and write data from the target device as it ensures that
	 * the last operation has finished before a new one will be called.</p>
	 *
	 * @param request new request to be added to the queue.
	 * @return the request to allow chaining
	 * @throws IllegalStateException if the device hasn't been connected (the BluetoothGattCallback is null)
	 */
	@NonNull
	protected <T extends Request> T enqueue(@NonNull final T request) {
		if (mGattCallback != null) {
			// Add the new task to the end of the queue
			mGattCallback.enqueue(request);
			runOnUiThread(() -> mGattCallback.nextRequest());
			return request;
		}
		throw new IllegalStateException("Device not connected");
	}

	private void runOnUiThread(final Runnable runnable) {
		if (Looper.myLooper() != Looper.getMainLooper()) {
			mHandler.post(runnable);
		} else {
			runnable.run();
		}
	}

	@SuppressWarnings({"WeakerAccess", "DeprecatedIsStillUsed"})
	protected abstract class BleManagerGattCallback extends MainThreadBluetoothGattCallback {
		private final static String ERROR_CONNECTION_STATE_CHANGE = "Error on connection state change";
		private final static String ERROR_DISCOVERY_SERVICE = "Error on discovering services";
		private final static String ERROR_AUTH_ERROR_WHILE_BONDED = "Phone has lost bonding information";
		private final static String ERROR_READ_CHARACTERISTIC = "Error on reading characteristic";
		private final static String ERROR_WRITE_CHARACTERISTIC = "Error on writing characteristic";
		private final static String ERROR_READ_DESCRIPTOR = "Error on reading descriptor";
		private final static String ERROR_WRITE_DESCRIPTOR = "Error on writing descriptor";
		private final static String ERROR_MTU_REQUEST = "Error on mtu request";
		private final static String ERROR_CONNECTION_PRIORITY_REQUEST = "Error on connection priority request";

		private final Deque<Request> mTaskQueue = new LinkedList<>();
		private Deque<Request> mInitQueue;
		private boolean mInitInProgress;
		private boolean mOperationInProgress = true; // Initially true to block operations before services are discovered.

		/**
		 * This flag is required to resume operations after the connection priority request was made.
		 * It is used only on Android Oreo and newer, as only there there is onConnectionUpdated callback.
		 * However, as this callback is triggered every time the connection parameters change, even
		 * when such request wasn't made, this flag ensures the nextRequest() method won't be called
		 * during another operation.
		 */
		private boolean mConnectionPriorityOperationInProgress = false;

		/**
		 * This method should return <code>true</code> when the gatt device supports the required services.
		 *
		 * @param gatt the gatt device with services discovered
		 * @return <code>True</code> when the device has the required service.
		 */
		protected abstract boolean isRequiredServiceSupported(final @NonNull BluetoothGatt gatt);

		/**
		 * This method should return <code>true</code> when the gatt device supports the optional services.
		 * The default implementation returns <code>false</code>.
		 *
		 * @param gatt the gatt device with services discovered
		 * @return <code>True</code> when the device has the optional service.
		 */
		protected boolean isOptionalServiceSupported(final @NonNull BluetoothGatt gatt) {
			return false;
		}

		/**
		 * This method should return a list of requests needed to initialize the profile.
		 * Enabling Service Change indications for bonded devices and reading the Battery Level value
		 * and enabling Battery Level notifications is handled before executing this queue.
		 * The queue should not have requests that are not available, e.g. should not read an
		 * optional service when it is not supported by the connected device.
		 * <p>
		 * This method is called when the services has been discovered and the device is supported
		 * (has required service).
		 * </p>
		 *
		 * @param gatt the gatt device with services discovered
		 * @return The queue of requests.
		 * @deprecated Use {@link #initialize()} instead.
		 */
		@Deprecated
		protected Deque<Request> initGatt(final @NonNull BluetoothGatt gatt) {
			return null;
		}

		/**
		 * This method should set up the request queue needed to initialize the profile.
		 * Enabling Service Change indications for bonded devices  is handled before executing this queue.
		 * The queue may have requests that are not available, e.g. read an optional service when
		 * it is not supported by the connected device. Such call will trigger
		 * {@link Request#fail(FailCallback)}.
		 * <p>
		 * This method is called when the services has been discovered and the device is supported
		 * (has required service).
		 * </p>
		 */
		protected void initialize() {
			// empty initialization queue
		}

		/**
		 * Called then the initialization queue is complete.
		 */
		protected void onDeviceReady() {
			mCallbacks.onDeviceReady(mBluetoothGatt.getDevice());
		}

		/**
		 * This method should nullify all services and characteristics of the device.
		 * It's called when the device is no longer connected, either due to user action
		 * or a link loss.
		 */
		protected abstract void onDeviceDisconnected();

		private void notifyDeviceDisconnected(final @NonNull BluetoothDevice device) {
			mConnected = false;
			mConnectionState = BluetoothGatt.STATE_DISCONNECTED;
			if (mUserDisconnected) {
				log(Level.INFO, "Disconnected");
				mCallbacks.onDeviceDisconnected(device);
				close();
			} else {
				log(Level.WARNING, "Connection lost");
				mCallbacks.onLinkLossOccurred(device);
				// We are not closing the connection here as the device should try to reconnect automatically.
				// This may be only called when the shouldAutoConnect() method returned true.
			}
			onDeviceDisconnected();
		}

		/**
		 * Callback reporting the result of a characteristic read operation.
		 *
		 * @param gatt           GATT client
		 * @param characteristic Characteristic that was read from the associated remote device.
		 * @deprecated Use {@link ReadRequest#with(DataReceivedCallback)} instead.
		 */
		@Deprecated
		protected void onCharacteristicRead(final @NonNull BluetoothGatt gatt, @NonNull final BluetoothGattCharacteristic characteristic) {
			// do nothing
		}

		/**
		 * Callback indicating the result of a characteristic write operation.
		 * <p>If this callback is invoked while a reliable write transaction is
		 * in progress, the value of the characteristic represents the value
		 * reported by the remote device. An application should compare this
		 * value to the desired value to be written. If the values don't match,
		 * the application must abort the reliable write transaction.
		 *
		 * @param gatt           GATT client
		 * @param characteristic Characteristic that was written to the associated remote device.
		 * @deprecated Use {@link WriteRequest#done(SuccessCallback)} instead.
		 */
		@Deprecated
		protected void onCharacteristicWrite(final @NonNull BluetoothGatt gatt, @NonNull final BluetoothGattCharacteristic characteristic) {
			// do nothing
		}

		/**
		 * Callback reporting the result of a descriptor read operation.
		 *
		 * @param gatt       GATT client
		 * @param descriptor Descriptor that was read from the associated remote device.
		 * @deprecated Use {@link ReadRequest#with(DataReceivedCallback)} instead.
		 */
		@Deprecated
		protected void onDescriptorRead(final @NonNull BluetoothGatt gatt, final @NonNull BluetoothGattDescriptor descriptor) {
			// do nothing
		}

		/**
		 * Callback indicating the result of a descriptor write operation.
		 * <p>If this callback is invoked while a reliable write transaction is in progress,
		 * the value of the characteristic represents the value reported by the remote device.
		 * An application should compare this value to the desired value to be written.
		 * If the values don't match, the application must abort the reliable write transaction.
		 *
		 * @param gatt       GATT client
		 * @param descriptor Descriptor that was written to the associated remote device.
		 * @deprecated Use {@link WriteRequest} and {@link no.nordicsemi.android.ble.callback.SuccessCallback} instead.
		 */
		@Deprecated
		protected void onDescriptorWrite(final @NonNull BluetoothGatt gatt, @NonNull final BluetoothGattDescriptor descriptor) {
			// do nothing
		}

		/**
		 * Callback reporting the value of Battery Level characteristic which could have
		 * been received by Read or Notify operations.
		 * <p>
		 * This method will not be called if {@link #readBatteryLevel()} and
		 * {@link #enableBatteryLevelNotifications()} were overridden.
		 * </p>
		 *
		 * @param gatt  GATT client
		 * @param value the battery value in percent
		 * @deprecated Use {@link ReadRequest#with(DataReceivedCallback)} and
		 * BatteryLevelDataCallback from BLE-Common-Library instead.
		 */
		@Deprecated
		protected void onBatteryValueReceived(final @NonNull BluetoothGatt gatt, final int value) {
			// do nothing
		}

		/**
		 * Callback indicating a notification has been received.
		 *
		 * @param gatt           GATT client
		 * @param characteristic Characteristic from which the notification came.
		 * @deprecated Use {@link ReadRequest#with(DataReceivedCallback)} instead.
		 */
		@Deprecated
		protected void onCharacteristicNotified(final @NonNull BluetoothGatt gatt, final @NonNull BluetoothGattCharacteristic characteristic) {
			// do nothing
		}

		/**
		 * Callback indicating an indication has been received.
		 *
		 * @param gatt           GATT client
		 * @param characteristic Characteristic from which the indication came.
		 * @deprecated Use {@link ReadRequest#with(DataReceivedCallback)} instead.
		 */
		@Deprecated
		protected void onCharacteristicIndicated(final @NonNull BluetoothGatt gatt, final @NonNull BluetoothGattCharacteristic characteristic) {
			// do nothing
		}

		/**
		 * Method called when the MTU request has finished with success. The MTU value may
		 * be different than requested one.
		 *
		 * @param gatt GATT client
		 * @param mtu  the new MTU (Maximum Transfer Unit)
		 * @deprecated Use {@link MtuRequest#with(MtuCallback)} instead.
		 */
		@Deprecated
		protected void onMtuChanged(final @NonNull BluetoothGatt gatt, final int mtu) {
			// do nothing
		}

		/**
		 * Callback indicating the connection parameters were updated. Works on Android 8+.
		 *
		 * @param gatt     GATT client
		 * @param interval Connection interval used on this connection, 1.25ms unit. Valid range is from
		 *                 6 (7.5ms) to 3200 (4000ms).
		 * @param latency  Slave latency for the connection in number of connection events. Valid range
		 *                 is from 0 to 499
		 * @param timeout  Supervision timeout for this connection, in 10ms unit. Valid range is from 10
		 *                 (0.1s) to 3200 (32s)
		 * @deprecated Use {@link ConnectionPriorityRequest#with(ConnectionPriorityCallback)} instead.
		 */
		@Deprecated
		@TargetApi(Build.VERSION_CODES.O)
		protected void onConnectionUpdated(final @NonNull BluetoothGatt gatt, final int interval, final int latency, final int timeout) {
			// do nothing
		}

		private void onError(final BluetoothDevice device, final String message, final int errorCode) {
			log(Level.ERROR, "Error (0x" + Integer.toHexString(errorCode) + "): " + GattError.parse(errorCode));
			mCallbacks.onError(device, message, errorCode);
		}

		@Override
		final void onConnectionStateChangeSafe(final BluetoothGatt gatt, final int status, final int newState) {
			log(Level.DEBUG, "[Callback] Connection state changed with status: " +
					status + " and new state: " + newState + " (" + stateToString(newState) + ")");

			if (status == BluetoothGatt.GATT_SUCCESS && newState == BluetoothProfile.STATE_CONNECTED) {
				// Notify the parent activity/service
				log(Level.INFO, "Connected to " + gatt.getDevice().getAddress());
				mConnected = true;
				mConnectionState = BluetoothGatt.STATE_CONNECTED;
				mCallbacks.onDeviceConnected(gatt.getDevice());

				/*
				 * The onConnectionStateChange event is triggered just after the Android connects to a device.
				 * In case of bonded devices, the encryption is reestablished AFTER this callback is called.
				 * Moreover, when the device has Service Changed indication enabled, and the list of services has changed (e.g. using the DFU),
				 * the indication is received few hundred milliseconds later, depending on the connection interval.
				 * When received, Android will start performing a service discovery operation on its own, internally,
				 * and will NOT notify the app that services has changed.
				 *
				 * If the gatt.discoverServices() method would be invoked here with no delay, if would return cached services,
				 * as the SC indication wouldn't be received yet.
				 * Therefore we have to postpone the service discovery operation until we are (almost, as there is no such callback) sure,
				 * that it has been handled.
				 * TODO: Please calculate the proper delay that will work in your solution.
				 * It should be greater than the time from LLCP Feature Exchange to ATT Write for Service Change indication.
				 * If your device does not use Service Change indication (for example does not have DFU) the delay may be 0.
				 */
				final boolean bonded = gatt.getDevice().getBondState() == BluetoothDevice.BOND_BONDED;
				final int delay = bonded ? 1600 : 0; // around 1600 ms is required when connection interval is ~45ms.
				if (delay > 0)
					log(Level.DEBUG, "wait(" + delay + ")");
				mHandler.postDelayed(() -> {
					// Some proximity tags (e.g. nRF PROXIMITY) initialize bonding automatically when connected.
					if (gatt.getDevice().getBondState() != BluetoothDevice.BOND_BONDING) {
						log(Level.VERBOSE, "Discovering Services...");
						log(Level.DEBUG, "gatt.discoverServices()");
						gatt.discoverServices();
					}
				}, delay);
			} else {
				if (newState == BluetoothProfile.STATE_DISCONNECTED) {
					if (status != BluetoothGatt.GATT_SUCCESS)
						log(Level.WARNING, "Error: (0x" + Integer.toHexString(status) + "): " +
								GattError.parseConnectionError(status));

					if (mRequest != null)
						mRequest.notifyFail(gatt.getDevice(), FailCallback.REASON_DEVICE_DISCONNECTED);
					for (final ValueChangedCallback callback : mNotificationCallbacks.values()) {
						callback.notifyDeviceDisconnected(gatt.getDevice());
					}

					mOperationInProgress = true; // no more calls are possible
					mInitQueue = null;
					mTaskQueue.clear();
					final boolean wasConnected = mConnected;

					// This sets the mConnected flag to false
					notifyDeviceDisconnected(gatt.getDevice());

					// Try to reconnect if the initial connection was lost because of a link loss or timeout,
					// and shouldAutoConnect() returned true during connection attempt.
					// This time it will set the autoConnect flag to true (gatt.connect() forces autoConnect true)
					if (mInitialConnection) {
						connect(gatt.getDevice());
					}

					if (wasConnected || status == BluetoothGatt.GATT_SUCCESS)
						return;
				} else {
					if (status != BluetoothGatt.GATT_SUCCESS)
						log(Level.ERROR, "Error (0x" + Integer.toHexString(status) + "): " +
								GattError.parseConnectionError(status));
				}
				mCallbacks.onError(gatt.getDevice(), ERROR_CONNECTION_STATE_CHANGE, status);
			}
		}

		@Override
		final void onServicesDiscoveredSafe(final BluetoothGatt gatt, final int status) {
			if (status == BluetoothGatt.GATT_SUCCESS) {
				log(Level.INFO, "Services Discovered");
				if (isRequiredServiceSupported(gatt)) {
					log(Level.VERBOSE, "Primary service found");
					final boolean optionalServicesFound = isOptionalServiceSupported(gatt);
					if (optionalServicesFound)
						log(Level.VERBOSE, "Secondary service found");

					// Notify the parent activity
					mCallbacks.onServicesDiscovered(gatt.getDevice(), optionalServicesFound);

					// Obtain the queue of initialization requests. First, let's call the deprecated initGatt(...).
					mInitInProgress = true;
					mInitQueue = initGatt(gatt);

					final boolean deprecatedApiUsed = mInitQueue != null;

					if (mInitQueue == null)
						mInitQueue = new LinkedList<>();

					// Before we start executing the initialization queue some other tasks need to be done.
					// Note, that operations are added in reverse order to the front of the queue.

					// 1. On devices running Android 4.3-6.0 the Service Changed characteristic needs
					//    to be enabled by the app (for bonded devices).
					//    The request will be ignored if there is no Service Changed characteristic.
					if (Build.VERSION.SDK_INT < Build.VERSION_CODES.N)
						enqueueFirst(Request.newEnableServiceChangedIndicationsRequest());

					// Deprecated:
					if (deprecatedApiUsed) {
						// All Battery Service handling will be removed from BleManager in the future.
						// If you want to read/enable notifications on Battery Level characteristic
						// do this in initialize(...).

						// 2. Read Battery Level characteristic (if such does not exist, this will be skipped)
						readBatteryLevel();
						// 3. Enable Battery Level notifications if required (if this char. does not
						//    exist, this operation will be skipped)
						if (mCallbacks.shouldEnableBatteryLevelNotifications(gatt.getDevice()))
							enableBatteryLevelNotifications();
					}
					// End

					initialize();

					mOperationInProgress = false;
					nextRequest();
				} else {
					log(Level.WARNING, "Device is not supported");
					mCallbacks.onDeviceNotSupported(gatt.getDevice());
					disconnect();
				}
			} else {
				Log.e(TAG, "onServicesDiscovered error " + status);
				onError(gatt.getDevice(), ERROR_DISCOVERY_SERVICE, status);
			}
		}

		@Override
		final void onCharacteristicReadSafe(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int status) {
			if (status == BluetoothGatt.GATT_SUCCESS) {
				log(Level.INFO, "Read Response received from " + characteristic.getUuid() +
						", value: " + ParserUtils.parse(characteristic));

				onCharacteristicRead(gatt, characteristic);
				((ReadRequest) mRequest).notifyValueChanged(gatt.getDevice(), characteristic.getValue());
				if (((ReadRequest) mRequest).hasMore()) {
					enqueueFirst(mRequest);
				} else {
					mRequest.notifySuccess(gatt.getDevice());
				}
			} else if (status == BluetoothGatt.GATT_INSUFFICIENT_AUTHENTICATION) {
				if (gatt.getDevice().getBondState() != BluetoothDevice.BOND_NONE) {
					// This should never happen but it used to: http://stackoverflow.com/a/20093695/2115352
					Log.w(TAG, ERROR_AUTH_ERROR_WHILE_BONDED);
					mCallbacks.onError(gatt.getDevice(), ERROR_AUTH_ERROR_WHILE_BONDED, status);
				}
				mRequest.notifyFail(gatt.getDevice(), status);
			} else {
				Log.e(TAG, "onCharacteristicRead error " + status);
				mRequest.notifyFail(gatt.getDevice(), status);
				onError(gatt.getDevice(), ERROR_READ_CHARACTERISTIC, status);
			}
			mOperationInProgress = false;
			nextRequest();
		}

		@Override
		final void onCharacteristicWriteSafe(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int status) {
			if (status == BluetoothGatt.GATT_SUCCESS) {
				log(Level.INFO, "Data written to " + characteristic.getUuid() +
						", value: " + ParserUtils.parse(characteristic));

				onCharacteristicWrite(gatt, characteristic);
				final WriteRequest request = (WriteRequest) mRequest;
				request.notifyPacketSent(gatt.getDevice(), characteristic.getValue());
				if (request.hasMore()) {
					enqueueFirst(mRequest);
				} else {
					mRequest.notifySuccess(gatt.getDevice());
				}
			} else if (status == BluetoothGatt.GATT_INSUFFICIENT_AUTHENTICATION) {
				if (gatt.getDevice().getBondState() != BluetoothDevice.BOND_NONE) {
					// This should never happen but it used to: http://stackoverflow.com/a/20093695/2115352
					Log.w(TAG, ERROR_AUTH_ERROR_WHILE_BONDED);
					mCallbacks.onError(gatt.getDevice(), ERROR_AUTH_ERROR_WHILE_BONDED, status);
				}
				mRequest.notifyFail(gatt.getDevice(), status);
			} else {
				Log.e(TAG, "onCharacteristicWrite error " + status);
				mRequest.notifyFail(gatt.getDevice(), status);
				onError(gatt.getDevice(), ERROR_WRITE_CHARACTERISTIC, status);
			}
			mOperationInProgress = false;
			nextRequest();
		}

		@Override
		final void onReliableWriteCompletedSafe(final BluetoothGatt gatt, final int status) {
			// TODO implement request
		}

		@Override
		void onDescriptorReadSafe(final BluetoothGatt gatt, final BluetoothGattDescriptor descriptor, final int status) {
			if (status == BluetoothGatt.GATT_SUCCESS) {
				log(Level.INFO, "Read Response received from descr. " + descriptor.getUuid() +
						", value: " + ParserUtils.parse(descriptor));

				onDescriptorRead(gatt, descriptor);
				((ReadRequest) mRequest).notifyValueChanged(gatt.getDevice(), descriptor.getValue());
				if (((ReadRequest) mRequest).hasMore()) {
					enqueueFirst(mRequest);
				} else {
					mRequest.notifySuccess(gatt.getDevice());
				}
			} else if (status == BluetoothGatt.GATT_INSUFFICIENT_AUTHENTICATION) {
				if (gatt.getDevice().getBondState() != BluetoothDevice.BOND_NONE) {
					// This should never happen but it used to: http://stackoverflow.com/a/20093695/2115352
					Log.w(TAG, ERROR_AUTH_ERROR_WHILE_BONDED);
					mCallbacks.onError(gatt.getDevice(), ERROR_AUTH_ERROR_WHILE_BONDED, status);
				}
				mRequest.notifyFail(gatt.getDevice(), status);
			} else {
				Log.e(TAG, "onDescriptorRead error " + status);
				mRequest.notifyFail(gatt.getDevice(), status);
				onError(gatt.getDevice(), ERROR_READ_DESCRIPTOR, status);
			}
			mOperationInProgress = false;
			nextRequest();
		}

		@Override
		final void onDescriptorWriteSafe(final BluetoothGatt gatt, final BluetoothGattDescriptor descriptor, final int status) {
			if (status == BluetoothGatt.GATT_SUCCESS) {
				log(Level.INFO, "Data written to descr. " + descriptor.getUuid() +
						", value: " + ParserUtils.parse(descriptor));

				if (isServiceChangedCCCD(descriptor)) {
					log(Level.APPLICATION, "Service Changed notifications enabled");
				} else if (isCCCD(descriptor)) {
					final byte[] value = descriptor.getValue();
					if (value != null && value.length == 2 && value[1] == 0x00) {
						switch (value[0]) {
							case 0x00:
								mNotificationCallbacks.remove(descriptor.getCharacteristic());
								log(Level.APPLICATION, "Notifications and indications disabled");
								break;
							case 0x01:
								log(Level.APPLICATION, "Notifications enabled");
								break;
							case 0x02:
								log(Level.APPLICATION, "Indications enabled");
								break;
						}
						onDescriptorWrite(gatt, descriptor);
					}
				} else {
					onDescriptorWrite(gatt, descriptor);
				}
				final WriteRequest request = (WriteRequest) mRequest;
				request.notifyPacketSent(gatt.getDevice(), descriptor.getValue());
				if (request.hasMore()) {
					enqueueFirst(mRequest);
				} else {
					mRequest.notifySuccess(gatt.getDevice());
				}
			} else if (status == BluetoothGatt.GATT_INSUFFICIENT_AUTHENTICATION) {
				if (gatt.getDevice().getBondState() != BluetoothDevice.BOND_NONE) {
					// This should never happen but it used to: http://stackoverflow.com/a/20093695/2115352
					Log.w(TAG, ERROR_AUTH_ERROR_WHILE_BONDED);
					mCallbacks.onError(gatt.getDevice(), ERROR_AUTH_ERROR_WHILE_BONDED, status);
				}
				mRequest.notifyFail(gatt.getDevice(), status);
			} else {
				Log.e(TAG, "onDescriptorWrite error " + status);
				mRequest.notifyFail(gatt.getDevice(), status);
				onError(gatt.getDevice(), ERROR_WRITE_DESCRIPTOR, status);
			}
			mOperationInProgress = false;
			nextRequest();
		}

		@Override
		final void onCharacteristicChangedSafe(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
			final String data = ParserUtils.parse(characteristic);

			if (isServiceChangedCharacteristic(characteristic)) {
				// TODO this should be tested. Should services be invalidated? Clal onDeviceDisconnected()?
				mOperationInProgress = true;
				log(Level.INFO, "Service Changed indication received");
				log(Level.VERBOSE, "Discovering Services...");
				log(Level.DEBUG, "gatt.discoverServices()");
				gatt.discoverServices();
			} else {
				final BluetoothGattDescriptor cccd = characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG_DESCRIPTOR_UUID);
				final boolean notifications = cccd == null || cccd.getValue() == null || cccd.getValue().length != 2 || cccd.getValue()[0] == 0x01;

				if (notifications) {
					log(Level.INFO, "Notification received from " + characteristic.getUuid() + ", value: " + data);
					onCharacteristicNotified(gatt, characteristic);
				} else { // indications
					log(Level.INFO, "Indication received from " + characteristic.getUuid() + ", value: " + data);
					onCharacteristicIndicated(gatt, characteristic);
				}
				if (mBatteryLevelNotificationCallback != null && isBatteryLevelCharacteristic(characteristic)) {
					mBatteryLevelNotificationCallback.notifyValueChanged(gatt.getDevice(), characteristic.getValue());
				}
				final ValueChangedCallback request = mNotificationCallbacks.get(characteristic);
				if (request != null) {
					request.notifyValueChanged(gatt.getDevice(), characteristic.getValue());
				}
			}
		}

		@Override
		final void onReadRemoteRssiSafe(final BluetoothGatt gatt, final int rssi, final int status) {
			// TODO implement request
		}

		@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
		@Override
		final void onMtuChangedSafe(final BluetoothGatt gatt, final int mtu, final int status) {
			if (status == BluetoothGatt.GATT_SUCCESS) {
				log(Level.INFO, "MTU changed to: " + mtu);
				mMtu = mtu;
				onMtuChanged(gatt, mtu);
				if (mRequest != null && mRequest instanceof MtuRequest) {
					((MtuRequest) mRequest).notifyMtuChanged(gatt.getDevice(), mtu);
					mRequest.notifySuccess(gatt.getDevice());
				}
			} else {
				Log.e(TAG, "onMtuChanged error: " + status + ", mtu: " + mtu);
				if (mRequest != null && mRequest instanceof MtuRequest) {
					mRequest.notifyFail(gatt.getDevice(), status);
				}
				onError(gatt.getDevice(), ERROR_MTU_REQUEST, status);
			}
			mOperationInProgress = false;
			nextRequest();
		}

		/**
		 * Callback indicating the connection parameters were updated. Works on Android 8+.
		 *
		 * @param gatt     GATT client involved
		 * @param interval Connection interval used on this connection, 1.25ms unit. Valid range is from
		 *                 6 (7.5ms) to 3200 (4000ms).
		 * @param latency  Slave latency for the connection in number of connection events. Valid range
		 *                 is from 0 to 499
		 * @param timeout  Supervision timeout for this connection, in 10ms unit. Valid range is from 10
		 *                 (0.1s) to 3200 (32s)
		 * @param status   {@link BluetoothGatt#GATT_SUCCESS} if the connection has been updated
		 *                 successfully
		 */
		@RequiresApi(api = Build.VERSION_CODES.O)
		@Override
		final void onConnectionUpdatedSafe(final BluetoothGatt gatt, final int interval, final int latency, final int timeout, final int status) {
			if (status == BluetoothGatt.GATT_SUCCESS) {
				log(Level.INFO, "Connection parameters updated (interval: " + (interval * 1.25) + "ms," +
						" latency: " + latency + ", timeout: " + (timeout * 10) + "ms)");
				onConnectionUpdated(gatt, interval, latency, timeout);

				// This callback may be called af any time, also when some other request is executed
				if (mRequest != null && mRequest instanceof ConnectionPriorityRequest) {
					((ConnectionPriorityRequest) mRequest).notifyConnectionPriorityChanged(gatt.getDevice(), interval, latency, timeout);
					mRequest.notifySuccess(gatt.getDevice());
				}
			} else if (status == 0x3b) { // HCI_ERR_UNACCEPT_CONN_INTERVAL
				Log.e(TAG, "onConnectionUpdated received status: Unacceptable connection interval, " +
						"interval: " + interval + ", latency: " + latency + ", timeout: " + timeout);
				log(Level.WARNING, "Connection parameters update failed with status: " +
						"UNACCEPT CONN INTERVAL (0x3b) (interval: " + (interval * 1.25) + "ms, " +
						"latency: " + latency + ", timeout: " + (timeout * 10) + "ms)");

				// This callback may be called af any time, also when some other request is executed
				if (mRequest != null && mRequest instanceof ConnectionPriorityRequest) {
					mRequest.notifyFail(gatt.getDevice(), status);
				}
			} else {
				Log.e(TAG, "onConnectionUpdated received status: " + status + ", " +
						"interval: " + interval + ", latency: " + latency + ", timeout: " + timeout);
				log(Level.WARNING, "Connection parameters update failed with " +
						"status " + status + " (interval: " + (interval * 1.25) + "ms, " +
						"latency: " + latency + ", timeout: " + (timeout * 10) + "ms)");

				// This callback may be called af any time, also when some other request is executed
				if (mRequest != null && mRequest instanceof ConnectionPriorityRequest) {
					mRequest.notifyFail(gatt.getDevice(), status);
				}
				mCallbacks.onError(gatt.getDevice(), ERROR_CONNECTION_PRIORITY_REQUEST, status);
			}
			if (mConnectionPriorityOperationInProgress) {
				mConnectionPriorityOperationInProgress = false;
				mOperationInProgress = false;
				nextRequest();
			}
		}

		@RequiresApi(api = Build.VERSION_CODES.O)
		@Override
		final void onPhyReadSafe(final BluetoothGatt gatt, final int txPhy, final int rxPhy, final int status) {
			if (status == BluetoothGatt.GATT_SUCCESS) {
				log(Level.INFO, "PHY read (TX: " + phyToString(txPhy) + ", RX: " + phyToString(rxPhy) + ")");
			} else {
				log(Level.WARNING, "PHY read failed with status " + status);
			}
			// TODO implement request
		}

		@RequiresApi(api = Build.VERSION_CODES.O)
		@Override
		final void onPhyUpdateSafe(final BluetoothGatt gatt, final int txPhy, final int rxPhy, final int status) {
			if (status == BluetoothGatt.GATT_SUCCESS) {
				log(Level.INFO, "PHY updated (TX: " + phyToString(txPhy) + ", RX: " + phyToString(rxPhy) + ")");
			} else {
				log(Level.WARNING, "PHY updated failed with status " + status);
			}
			// TODO implement request
		}

		/**
		 * Enqueues the given request at the front of the the init or task queue, depending
		 * on whether the initialization has is in progress, or not.
		 *
		 * @param request the request to be added.
		 */
		private void enqueueFirst(final Request request) {
			final Deque<Request> queue = mInitInProgress ? mInitQueue : mTaskQueue;
			queue.addFirst(request);
		}

		/**
		 * Enqueues the given request at the end of the the init or task queue, depending
		 * on whether the initialization has is in progress, or not.
		 *
		 * @param request the request to be added.
		 */
		private void enqueue(final Request request) {
			final Deque<Request> queue = mInitInProgress ? mInitQueue : mTaskQueue;
			queue.add(request);
		}

		/**
		 * Removes all enqueued requests from the queue.
		 * Does not affect the Init queue created with {@link #initGatt(BluetoothGatt)}.
		 */
		protected void cancelQueue() {
			mTaskQueue.clear();
		}

		/**
		 * Executes the next request. If the last element from the initialization queue has been executed
		 * the {@link #onDeviceReady()} callback is called.
		 */
		private void nextRequest() {
			if (mOperationInProgress)
				return;

			// Get the first request from the init queue
			Request request = mInitQueue != null ? mInitQueue.poll() : null;

			// Are we done with initializing?
			if (request == null) {
				if (mInitInProgress) {
					mInitInProgress = false;
					mInitQueue = null; // release the queue
					onDeviceReady();
				}
				// If so, we can continue with the task queue
				request = mTaskQueue.poll();
				if (request == null) {
					mRequest = null;
					return;
				}
			}

			mRequest = request;
			mOperationInProgress = true;
			boolean result = false;
			switch (request.type) {
				case CREATE_BOND: {
					result = internalCreateBond();
					break;
				}
				case READ: {
					result = internalReadCharacteristic(request.characteristic);
					break;
				}
				case WRITE: {
					final WriteRequest wr = (WriteRequest) request;
					final BluetoothGattCharacteristic characteristic = request.characteristic;
					if (characteristic != null) {
						characteristic.setValue(wr.getData(mMtu));
						characteristic.setWriteType(wr.getWriteType());
					}
					result = internalWriteCharacteristic(characteristic);
					break;
				}
				case READ_DESCRIPTOR: {
					result = internalReadDescriptor(request.descriptor);
					break;
				}
				case WRITE_DESCRIPTOR: {
					final WriteRequest wr = (WriteRequest) request;
					final BluetoothGattDescriptor descriptor = request.descriptor;
					if (descriptor != null) {
						descriptor.setValue(wr.getData(mMtu));
					}
					result = internalWriteDescriptor(descriptor);
					break;
				}
				case ENABLE_NOTIFICATIONS: {
					result = internalEnableNotifications(request.characteristic);
					break;
				}
				case ENABLE_INDICATIONS: {
					result = internalEnableIndications(request.characteristic);
					break;
				}
				case DISABLE_NOTIFICATIONS: {
					result = internalDisableNotifications(request.characteristic);
					break;
				}
				case DISABLE_INDICATIONS: {
					result = internalDisableIndications(request.characteristic);
					break;
				}
				case READ_BATTERY_LEVEL: {
					result = internalReadBatteryLevel();
					break;
				}
				case ENABLE_BATTERY_LEVEL_NOTIFICATIONS: {
					result = internalSetBatteryNotifications(true);
					break;
				}
				case DISABLE_BATTERY_LEVEL_NOTIFICATIONS: {
					result = internalSetBatteryNotifications(false);
					break;
				}
				case ENABLE_SERVICE_CHANGED_INDICATIONS: {
					result = ensureServiceChangedEnabled();
					break;
				}
				case REQUEST_MTU: {
					if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
						result = internalRequestMtu(((MtuRequest) request).getRequiredMtu());
					} else {
						((MtuRequest) request).notifyMtuChanged(mBluetoothDevice, mMtu);
						request.notifySuccess(mBluetoothDevice);
						result = true;
					}
					break;
				}
				case REQUEST_CONNECTION_PRIORITY: {
					final ConnectionPriorityRequest cpr = (ConnectionPriorityRequest) request;
					if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
						mConnectionPriorityOperationInProgress = true;
						result = internalRequestConnectionPriority(cpr.getRequiredPriority());
					} else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
						result = internalRequestConnectionPriority(cpr.getRequiredPriority());
						// There is no callback for requestConnectionPriority(...) before Android Oreo.\
						// Let's give it some time to finish as the request is an asynchronous operation.
						if (result) {
							mHandler.postDelayed(() -> {
								mRequest.notifySuccess(mBluetoothDevice);
								mOperationInProgress = false;
								nextRequest();
							}, 100);
						}
					}
					break;
				}
			}
			// The result may be false if given characteristic or descriptor were not found on the device,
			// or the feature is not supported on the Android.
			// In that case, proceed with next operation and ignore the one that failed.
			if (!result) {
				mRequest.notifyFail(mBluetoothDevice, mConnected ? FailCallback.REASON_NULL_ATTRIBUTE : FailCallback.REASON_DEVICE_DISCONNECTED);
				mConnectionPriorityOperationInProgress = false;
				mOperationInProgress = false;
				nextRequest();
			}
		}

		/**
		 * Returns true if this descriptor is from the Service Changed characteristic.
		 *
		 * @param descriptor the descriptor to be checked
		 * @return true if the descriptor belongs to the Service Changed characteristic
		 */
		private boolean isServiceChangedCCCD(final BluetoothGattDescriptor descriptor) {
			return descriptor != null && SERVICE_CHANGED_CHARACTERISTIC.equals(descriptor.getCharacteristic().getUuid());
		}

		/**
		 * Returns true if this is the Service Changed characteristic.
		 *
		 * @param characteristic the characteristic to be checked
		 * @return true if it is the Service Changed characteristic
		 */
		private boolean isServiceChangedCharacteristic(final BluetoothGattCharacteristic characteristic) {
			return characteristic != null && SERVICE_CHANGED_CHARACTERISTIC.equals(characteristic.getUuid());
		}

		/**
		 * Returns true if the characteristic is the Battery Level characteristic.
		 *
		 * @param characteristic the characteristic to be checked
		 * @return true if the characteristic is the Battery Level characteristic.
		 */
		@Deprecated
		private boolean isBatteryLevelCharacteristic(final BluetoothGattCharacteristic characteristic) {
			return characteristic != null && BATTERY_LEVEL_CHARACTERISTIC.equals(characteristic.getUuid());
		}

		/**
		 * Returns true if this descriptor is a Client Characteristic Configuration descriptor (CCCD).
		 *
		 * @param descriptor the descriptor to be checked
		 * @return true if the descriptor is a CCCD
		 */
		private boolean isCCCD(final BluetoothGattDescriptor descriptor) {
			return descriptor != null && CLIENT_CHARACTERISTIC_CONFIG_DESCRIPTOR_UUID.equals(descriptor.getUuid());
		}
	}

	protected static final int PAIRING_VARIANT_PIN = 0;
	protected static final int PAIRING_VARIANT_PASSKEY = 1;
	protected static final int PAIRING_VARIANT_PASSKEY_CONFIRMATION = 2;
	protected static final int PAIRING_VARIANT_CONSENT = 3;
	protected static final int PAIRING_VARIANT_DISPLAY_PASSKEY = 4;
	protected static final int PAIRING_VARIANT_DISPLAY_PIN = 5;
	protected static final int PAIRING_VARIANT_OOB_CONSENT = 6;

	protected String pairingVariantToString(final int variant) {
		switch (variant) {
			case PAIRING_VARIANT_PIN:
				return "PAIRING_VARIANT_PIN";
			case PAIRING_VARIANT_PASSKEY:
				return "PAIRING_VARIANT_PASSKEY";
			case PAIRING_VARIANT_PASSKEY_CONFIRMATION:
				return "PAIRING_VARIANT_PASSKEY_CONFIRMATION";
			case PAIRING_VARIANT_CONSENT:
				return "PAIRING_VARIANT_CONSENT";
			case PAIRING_VARIANT_DISPLAY_PASSKEY:
				return "PAIRING_VARIANT_DISPLAY_PASSKEY";
			case PAIRING_VARIANT_DISPLAY_PIN:
				return "PAIRING_VARIANT_DISPLAY_PIN";
			case PAIRING_VARIANT_OOB_CONSENT:
				return "PAIRING_VARIANT_OOB_CONSENT";
			default:
				return "UNKNOWN";
		}
	}

	protected String bondStateToString(final int state) {
		switch (state) {
			case BluetoothDevice.BOND_NONE:
				return "BOND_NONE";
			case BluetoothDevice.BOND_BONDING:
				return "BOND_BONDING";
			case BluetoothDevice.BOND_BONDED:
				return "BOND_BONDED";
			default:
				return "UNKNOWN";
		}
	}

	protected String writeTypeToString(final int type) {
		switch (type) {
			case BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT:
				return "WRITE REQUEST";
			case BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE:
				return "WRITE COMMAND";
			case BluetoothGattCharacteristic.WRITE_TYPE_SIGNED:
				return "WRITE SIGNED";
			default:
				return "UNKNOWN: " + type;
		}
	}

	/**
	 * Converts the connection state to String value.
	 *
	 * @param state the connection state
	 * @return state as String
	 */
	protected String stateToString(final int state) {
		switch (state) {
			case BluetoothProfile.STATE_CONNECTED:
				return "CONNECTED";
			case BluetoothProfile.STATE_CONNECTING:
				return "CONNECTING";
			case BluetoothProfile.STATE_DISCONNECTING:
				return "DISCONNECTING";
			default:
				return "DISCONNECTED";
		}
	}

	/**
	 * Converts the PHY number to String value.
	 * @param phy phy value
	 * @return phy as String
	 */
	@RequiresApi(value = Build.VERSION_CODES.O)
	private String phyToString(final int phy) {
		switch (phy) {
			case BluetoothDevice.PHY_LE_1M:
				return "LE 1M";
			case BluetoothDevice.PHY_LE_2M:
				return "LE 2M";
			case BluetoothDevice.PHY_LE_CODED:
				return "LE Coded";
			default:
				return "UNKNOWN (" + phy + ")";
		}
	}
}
